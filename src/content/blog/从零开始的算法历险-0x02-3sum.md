---
title: "从零开始的算法历险 — 0x02 3-Sum"
pubDate: 2020-07-30 10:00:00
tags:
- Algorithm
- LeetCode
- C++
- Two Pointers
series: "算法历险"
seriesOrder: 2
description: "探索三数之和问题，学习排序加双指针的经典算法技巧。"
---

## 2. 三数之和(3-Sum)

### 2.1 问题描述

> 给你一个包含 n 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 a, b, c，使得 a + b + c = 0？
> 
> 请你找出所有**和为 0 且不重复**的三元组。

**示例：**

```
输入：nums = [-1, 0, 1, 2, -1, -4]
输出：[[-1, -1, 2], [-1, 0, 1]]

解释：
- nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0
- nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0
- nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0
```

**注意：** 答案中不可以包含重复的三元组。

### 2.2 问题分析

相比 Two Sum，3-Sum 有以下难点：
1. **目标值固定为 0**（实际上是 target = 0 的特殊情况）
2. **需要返回所有满足条件的组合**，而不仅仅是一个
3. **需要去重**，避免输出重复的三元组

#### 2.2.1 暴力解法

三层循环枚举所有三元组：

```mermaid
flowchart TD
    A["开始"] --> B["i = 0"]
    B --> C{"i < n?"}
    C -->|Yes| D["j = i + 1"]
    D --> E{"j < n?"}
    E -->|Yes| F["k = j + 1"]
    F --> G{"k < n?"}
    G -->|Yes| H{"nums[i]+nums[j]+nums[k]==0?"}
    H -->|Yes| I["记录三元组"]
    H -->|No| J["k++"]
    I --> J
    J --> G
    G -->|No| K["j++"]
    K --> E
    E -->|No| L["i++"]
    L --> C
    C -->|No| M["去重并返回结果"]
    M --> N["结束"]
```

**时间复杂度：** O(n³) - 三层循环
**空间复杂度：** O(k) - 存储结果，k 为结果数量

#### 2.2.2 排序 + 双指针优化

这是 3-Sum 问题的经典解法，核心思想：
1. **排序**数组，便于去重和双指针移动
2. **固定一个数**，将问题转化为 Two Sum
3. 使用**双指针**在有序数组中寻找两数之和

```mermaid
flowchart TD
    A["开始"] --> B["对数组排序"]
    B --> C["i = 0"]
    C --> D{"i < n - 2?"}
    D -->|Yes| E["跳过重复元素"]
    E --> F["left = i + 1, right = n - 1"]
    F --> G{"left < right?"}
    G -->|Yes| H["sum = nums[i] + nums[left] + nums[right]"]
    H --> I{"sum == 0?"}
    I -->|Yes| J["记录三元组"]
    J --> K["跳过左边重复元素"]
    K --> L["跳过右边重复元素"]
    L --> M["left++, right--"]
    I -->|sum < 0| N["left++"]
    I -->|sum > 0| O["right--"]
    N --> G
    O --> G
    M --> G
    G -->|No| P["i++"]
    P --> D
    D -->|No| Q["返回结果"]
    Q --> R["结束"]
```

**核心思想图解：**

```mermaid
graph LR
    subgraph "排序后数组"
        A1[-4]
        A2[-1]
        A3[-1]
        A4[0]
        A5[1]
        A6[2]
    end
    
    subgraph "固定 i=0, nums[i]=-4"
        B1["left=1<br/>nums[left]=-1"]
        B2["..."]
        B3["right=5<br/>nums[right]=2"]
    end
    
    subgraph "计算 sum"
        C1["sum = -4 + (-1) + 2 = -3 < 0"]
        C2["需要更大的数"]
        C3["left++"]
    end
    
    A1 -.-> B1
    A6 -.-> B3
    B1 -.-> C1
    B3 -.-> C1
```

**时间复杂度：** O(n²) - 外层循环 O(n)，双指针遍历 O(n)
**空间复杂度：** O(1) 或 O(k) - 排序可能使用 O(log n) 栈空间，结果存储 O(k)

### 2.3 代码实现

#### 2.3.1 排序 + 双指针

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        int n = nums.size();
        
        // 数组长度不足 3，直接返回
        if (n < 3) return result;
        
        // 1. 排序
        sort(nums.begin(), nums.end());
        
        // 2. 固定第一个数，转化为 Two Sum 问题
        for (int i = 0; i < n - 2; i++) {
            // 优化：如果当前数已经大于 0，后面的数都大于 0，不可能和为 0
            if (nums[i] > 0) break;
            
            // 跳过重复元素，避免重复解
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            
            // 3. 双指针寻找另外两个数
            int left = i + 1;
            int right = n - 1;
            
            while (left < right) {
                long long sum = (long long)nums[i] + nums[left] + nums[right];
                
                if (sum == 0) {
                    // 找到一组解
                    result.push_back({nums[i], nums[left], nums[right]});
                    
                    // 跳过左边重复元素
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    // 跳过右边重复元素
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    
                    left++;
                    right--;
                } else if (sum < 0) {
                    // 和小于 0，需要增大，左指针右移
                    left++;
                } else {
                    // 和大于 0，需要减小，右指针左移
                    right--;
                }
            }
        }
        
        return result;
    }
};
```

### 2.4 算法执行过程可视化

以 `nums = [-1, 0, 1, 2, -1, -4]` 为例：

**Step 1: 排序**
```
原始: [-1, 0, 1, 2, -1, -4]
排序: [-4, -1, -1, 0, 1, 2]
```

**Step 2: 遍历过程**

```mermaid
graph TB
    subgraph "i = 0, nums[i] = -4"
        A1["left=1(-1), right=5(2)"]
        A2["sum = -4-1+2 = -3 < 0"]
        A3["left++ → left=2(-1)"]
        A4["sum = -4-1+2 = -3 < 0"]
        A5["left++ → left=3(0)"]
        A6["sum = -4+0+2 = -2 < 0"]
        A7["left++ → left=4(1)"]
        A8["sum = -4+1+2 = -1 < 0"]
        A9["left++ → left=5, left>=right, 结束"]
    end
    
    subgraph "i = 1, nums[i] = -1 (第一个-1)"
        B1["left=2(-1), right=5(2)"]
        B2["sum = -1-1+2 = 0 ✓"]
        B3["记录 [-1, -1, 2]"]
        B4["跳过重复, left=3(0), right=4(1)"]
        B5["sum = -1+0+1 = 0 ✓"]
        B6["记录 [-1, 0, 1]"]
    end
    
    subgraph "i = 2, nums[i] = -1 (第二个-1)"
        C1["nums[i] == nums[i-1], 跳过避免重复"]
    end
    
    A1 --> A2 --> A3 --> A4 --> A5 --> A6 --> A7 --> A8 --> A9
    A9 --> B1
    B1 --> B2 --> B3 --> B4 --> B5 --> B6
    B6 --> C1
```

### 2.5 关键点总结

#### 2.5.1 为什么排序后能用双指针？

```mermaid
graph LR
    A["排序后数组"] --> B["单调递增"]
    B --> C["固定一个数后"]
    C --> D["剩余两数之和需为定值"]
    D --> E["左指针右移 → 和增大"]
    D --> F["右指针左移 → 和减小"]
    E --> G["可控制系统性搜索"]
    F --> G
```

#### 2.5.2 去重的三个位置

```mermaid
flowchart TD
    A["3-Sum 去重"] --> B["i 去重"]
    A --> C["left 去重"]
    A --> D["right 去重"]
    
    B --> B1["i > 0 && nums[i] == nums[i-1]"]
    B1 --> B2["跳过当前 i"]
    
    C --> C1["找到解后"]
    C1 --> C2["while left < right && nums[left] == nums[left+1]"]
    C2 --> C3["left++"]
    
    D --> D1["找到解后"]
    D1 --> D2["while left < right && nums[right] == nums[right-1]"]
    D2 --> D3["right--"]
```

### 2.6 复杂度对比

| 解法 | 时间复杂度 | 空间复杂度 | 特点 |
|------|-----------|-----------|------|
| 暴力枚举 | O(n³) | O(k) | 简单直接，超时 |
| 哈希表 | O(n²) | O(n) | 类似 Two Sum 扩展 |
| 排序+双指针 | O(n²) | O(1) ~ O(log n) | 最优，且易于去重 |

### 2.7 从 2-Sum 到 3-Sum 的思维演进

```mermaid
graph LR
    A["2-Sum<br/>target"] --> B["哈希表<br/>O(n)"]
    A --> C["排序+双指针<br/>O(n log n)"]
    
    D["3-Sum<br/>target=0"] --> E["固定一个数"]
    E --> F["转化为 2-Sum"]
    F --> G["排序+双指针<br/>O(n²)"]
    
    B -.->|扩展思路| H["4-Sum<br/>固定两个数<br/>哈希表 O(n²)"]
    G -.->|扩展思路| I["4-Sum<br/>排序+双指针 O(n³)"]
```

### 2.8 进阶：k-Sum 问题的通解思路

通过 2-Sum 和 3-Sum，我们可以总结出 k-Sum 的一般解法：

```
k-Sum 问题通用框架：

1. 排序数组（如果需要双指针）
2. 递归地固定 k-2 个数
3. 最后使用双指针解决 2-Sum 问题

时间复杂度：O(n^(k-1))
```

### 2.9 总结

3-Sum 问题教会我们的算法技巧：

1. **排序预处理** - 为双指针创造条件，同时简化去重
2. **降维思想** - 将 k-Sum 问题分解为 (k-1)-Sum 问题
3. **双指针技巧** - 利用有序性实现 O(n) 的两数搜索
4. **去重技巧** - 在循环的每个层次都要考虑重复元素的跳过

这些技巧不仅适用于 Sum 类问题，也是解决数组、字符串等问题的常用方法。

---

## 参考

- [LeetCode 15. 3Sum](https://leetcode.com/problems/3sum/)
- [LeetCode 16. 3Sum Closest](https://leetcode.com/problems/3sum-closest/)
- [LeetCode 18. 4Sum](https://leetcode.com/problems/4sum/)
